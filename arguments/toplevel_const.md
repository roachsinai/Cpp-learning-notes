# 顶层const

const另一个不好理解的就是**带有顶层const**的形参的const会被忽略！也就是：

{%ace edit=true, lang='c_cpp'%}
A: foo(int a){}

B: foo(const int a){}
{%endace%}

不能是重载， `c++ Primer` 中文版给的说明是形参列表应该有明显不同（不吐不快：这还不明显）。

~~应该说是迁就 `C`,在 C 语言里，版本 A 和版本 B 是没有区别的。如果这两个版本定义在相同的作用域中，C 编译器就会认为是函数重定义，而不是函数重载，因为 C 中根本就没有重载的概念。~~

当函数参数只采用值传递时（`C语言`没有引用传递），const 只是告诉编译器，形参在函数里面值是不可以被改变的。但是这已经跟实参没有任何关系了，传递进来的只不过是一个副本。也就是对于调用者（`caller`）而言，这两种方式定义的函数结果都是一致的。

另外，可以重编译器的角度考虑一下。

{%ace edit=true, lang='c_cpp'%}
int a = 42;

A: foo(a);
B: foo(42);
{%endace%}

我们知道值传递时是将实参（argument）的值复制给形参（parameter），那么如果`top-level const`造成了重载，那对于上面函数重载的两种形式`A`和`B`需要定义歌优先级（对于一个传过来的整型值，它们都可以接受）。但是，如果确定了优先级，那么就只有一种形式可以生效，比如上面调用`foo(a)`和`foo(42)`，不可能实现前一个调用非`const`定义的`foo`函数，而后一个调用`const`定义的`foo`函数。

与之不同的是传`引用`和指针，传引用会对实参造成影响，即**引用和指针的顶层const产生重载**，它们也确实会对调用者产生影响。